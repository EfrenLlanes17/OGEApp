@page "/"

@rendermode InteractiveServer

@using MudBlazor
@using MudBlazor.Services;


@inject NavigationManager Navigation

<PageTitle>Upload</PageTitle>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">

<style>
    body {
        background-color: black;
        color: white;
        font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif
    }

    .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            width: 100%;
            height: 100%;
        }
</style>




<div class="container">
<h1 style="font-weight: bold; font-size: 35px; text-align: center; margin-top: 10%;">Welcome To</h1>

<img src="images/whiteInflowLogo.png" alt="Inflow Logo" width="325" height="75" style="align-content: center; margin-top: 1%;">


@* <MudFileUpload T="IBrowserFile" FilesChanged="FileUploaded">
    <ActivatorContent>
        <MudButton Variant="Variant.Filled"
                   Class="custom-upload-button"
                   Style="background-color: black; color: white; font-weight: bold; font-size: 20px; width: 100%; border-width: 1mm; border-color: white; cursor: pointer; text-align: center; margin-top: 10%;"
                   StartIcon="@Icons.Material.Filled.CloudUpload">
            Upload File
        </MudButton>
    </ActivatorContent>
</MudFileUpload> *@



 <label for="fileUpload" class="btn btn-primary rounded-pill"
       style="background-color: black; color: white; font-weight: bold; font-size: 20px; width: 20%; border-width: 1mm; border-color: white; cursor: pointer; text-align: center; margin-top: 10%">
    Upload File
    <InputFile id="fileUpload" OnChange="FileUploaded" accept=".csv" style="display: none;" />
</label>
</div> 

@* @if(file != null || Series.Count != 0){
<MudSimpleTable Style="overflow-x: auto;">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>File Size(bytes)</th>
                </tr>
            </thead>
    using OGEApp.Components.Layout;
    using OGEApp.Components.Layout;
            <tbody>
            <tr>
                    <td>@file.Name</td>
                    <td>@file.Size</td>
              </tr>  
    </tbody>
    </MudSimpleTable> 



    <MudSimpleTable Style="overflow-x: auto; background-color: rgb(75, 72, 72);">
    <thead>
        <tr>
            <th>Day of the Week</th>
            <th>Event Count</th>
        </tr>
    </thead>
    <tbody>
        @foreach (var entry in eventsByDayOfWeek)
        {
            <tr>
                <td>@entry.Key</td>
                <td>@entry.Value.Count</td>
            </tr>
        }
    </tbody>
</MudSimpleTable>



    <div>
    <MudChart ChartType="ChartType.Line" ChartSeries="@Series" @bind-SelectedIndex="Index" XAxisLabels="@XAxisLabels" Width="100%" Height="350px" ChartOptions="@Options"/>
    <MudGrid>
         <MudItem xs="6">
            <MudText Typo="Typo.body1" Class="py-3">Selected: @(Index < 0 ? "None" : Series[Index].Name)</MudText>
        </MudItem>
        <MudItem xs="6">
            <MudSlider @bind-Value="Options.LineStrokeWidth" Min="1" Max="10" Color="Color.Info">Line Width: @Options.LineStrokeWidth.ToString()</MudSlider>
        </MudItem> 
    </MudGrid>
</div>
} *@




@code {

 public static IBrowserFile file { get; set; }
    public string FileName { get; set; } = "";
    public long FileSize { get; set; }
    public string FileType { get; set; } = "";
    public string ListSize { get; set; } = "";
    public DateTimeOffset LastModified { get; set; }
    public string ErrorMessage { get; set; } = "";

    const int MAX_FILESIZE = 5000 * 1024; // 5 MB

    private Dictionary<string, List<ReaderEvent>> readerEvents = new();
    public static Dictionary<string, List<ReaderEvent>> eventsByDayOfWeek = new();
    public static List<ReaderEvent> Entries = new();



private int Index = -1; 
    public ChartOptions Options = new ChartOptions();





    
    public static List<ChartSeries> Series = new List<ChartSeries>()
    {
    };

    public static List<ChartSeries> SeriesPeople = new List<ChartSeries>()
    {
    };

    public static List<ChartSeries> SeriesReaders = new List<ChartSeries>()
    {
    };

    public static List<ChartSeries> SeriesPanel = new List<ChartSeries>()
    {
    };
    public string[] XAxisLabels = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };

    public static string[] XAxisLabelsforPeople = {};

    public static string[] XAxisLabelsforReaders = {};

    public static string[] XAxisLabelsforPanels = {};

    public static DateTime firstDay;
    public static DateTime LastDay;


    public static List<string> listOfErrors = new List<string>();

public static int openTime = 9;

public static int closeTime = 17;

public static int SCAN_THRESHOLDForPannel = 4000;

public static int SCAN_THRESHOLDForReader = 2000;

public static int nearPannel = 100;

public static int nearReader = 100;

public static Boolean PanelsOver= true;

public static Boolean PanelsNear= true;

public static Boolean ReadersOver= true;

public static Boolean ReadersNear= true;

public static Boolean afterHoursBool = true;

public static Boolean dupBool = false;



    public async Task FileUploaded(InputFileChangeEventArgs e)
    {
        
        var browserFile = e.File;
        file = browserFile;

        if (browserFile != null)
        {
            FileSize = browserFile.Size;
            FileType = browserFile.ContentType;
            FileName = browserFile.Name;
            LastModified = browserFile.LastModified;

            try
            {
                using var memoryStream = new MemoryStream();
                await browserFile.OpenReadStream(MAX_FILESIZE).CopyToAsync(memoryStream);

                memoryStream.Position = 0;
                using var reader = new StreamReader(memoryStream);

                string line;
                bool firstLine = true;
                Entries.Clear();

                while ((line = await reader.ReadLineAsync()) != null)
                {
                    if (!firstLine)
                    {
                        var columns = line.Split(',');
                        Entries.Add(new ReaderEvent(columns[0], columns[1], columns[2], columns[3], int.Parse(columns[4]), int.Parse(columns[5])));
                    }
                    else
                    {
                        firstLine = false;
                    }
                }
                

                
            
                ListSize = Entries.Count.ToString();
                readerEvents = OrganizeEventsByReader(Entries);
                eventsByDayOfWeek = OrganizeEventsByDayOfWeek(Entries);
            
                SeriesPeople.Clear();
                SeriesPeople.Add(new ChartSeries() { Name = "# of Entries", Data = GetTopActivePeopleCounts().ToArray()});
                XAxisLabelsforPeople = GetTopActivePeopleNames().ToArray();

                SeriesReaders.Clear();
                SeriesReaders.Add(new ChartSeries() { Name = "# of Entries", Data = GetTopActiveReadersCounts().ToArray()});
                XAxisLabelsforReaders= GetTopActiveReaders().ToArray();

                SeriesPanel.Clear();
                SeriesPanel.Add(new ChartSeries() { Name = "# of Entries", Data = GetTopActivePanelCounts().ToArray()});
                XAxisLabelsforPanels= GetTopActivePanels().ToArray();

                @* Console.WriteLine(Entries.Last().Time);
                Console.WriteLine( DateTime.Parse(Entries.Last().Time).ToString());
                Console.WriteLine(GetFirstDate().ToString());
                Console.WriteLine(GetLastDate().ToString()); *@

                @* foreach(string s in CheckForPotentialIssues(Entries).ToArray()){
                   Console.WriteLine(s);
                } *@
                Console.WriteLine(CheckForPotentialIssues(Entries).Count);

                
                listOfErrors = CheckForPotentialIssues(Entries);

                 @* List<string> machineIssues = Entries
                    .GroupBy(e => e.DevID)  
                    .Select(g => g.Key.ToString() + " "+ g.Count().ToString())  
                    .ToList();

               
                
                    Console.WriteLine(machineIssues.Count); *@
                


                
                
                
                firstDay = GetFirstDate();
                LastDay = GetLastDate().AddDays(1);

                Pages.Activity.selectedDateMin = firstDay;
                Pages.Activity.selectedDateMax = LastDay;

                Pages.Activity.entriesAndExit =  Entries.Count;

                Pages.Activity.amountPeople =  GetUniquePeopleCount();

                Components.Pages.Activity.listOflocations.Clear();
                foreach(string s in GetLocations()){
                    Components.Pages.Activity.listOflocations.Add(s);
                }
                Components.Pages.Activity.location = GetLocations().ToArray()[0];



                Navigation.NavigateTo("/Activity");
            }
            catch (Exception exception)
            {
                ErrorMessage = exception.Message;
            }
        }
    }

    public List<string> CheckForPotentialIssues(List<ReaderEvent> entries)
{
    @* int SCAN_THRESHOLDForPannel = 4000; //4000
    int nearPannel = 100;

    int SCAN_THRESHOLDForReader = 2000; //2000
    int nearReader = 100; *@

    int closingTime = closeTime;

    int openingTime = openTime;

//Does not account for Day lights saving time and only works for UTE to CTE. Regular is +6 but its DST
    int openingTimeUtc = openingTime +  5;
    int closingTimeUtc = closingTime + 5 ;
    if(closingTimeUtc > 12){
        closingTimeUtc -= 12;
    }

    List<string> issues = new List<string>();

    var afterHours = entries
    .Where(e => 
    DateTime.Parse(e.Time).Hour < openingTimeUtc || DateTime.Parse(e.Time).Hour > closingTimeUtc)
    .Select(e => new { e.IDHash, e.Time, e.ReaderDesc })
    .ToList();


    var duplicateScans = entries
    .OrderBy(e => e.IDHash).ThenBy(e => e.Time)
    .GroupBy(e => e.IDHash)
    .SelectMany(group =>
        group.Zip(group.Skip(1), (a, b) => new { Prev = a, Curr = b , PrevTime = DateTime.Parse(a.Time), CurrTime = DateTime.Parse(b.Time) })
             .Where(pair =>
                 pair.Prev.ReaderDesc == pair.Curr.ReaderDesc &&
                 pair.Prev.IDHash == pair.Curr.IDHash &&
                  pair.Prev.DevID == pair.Curr.DevID &&
                  pair.Prev.Machine == pair.Curr.Machine &&
                 pair.CurrTime  == pair.PrevTime 
             )
             .Select(pair => pair.Curr)
    )
    .ToList();


   
    var machineIssuesOver = entries
        .GroupBy(e => e.Machine)  
        .Where(g => g.Count() >= SCAN_THRESHOLDForPannel)
        .Select(g => new { Machine = g.Key, Count = g.Count() })
        .ToList();

         var machineIssuesNear = entries
        .GroupBy(e => e.Machine)  
        .Where(g => g.Count() + nearPannel >= SCAN_THRESHOLDForPannel && g.Count() < SCAN_THRESHOLDForPannel)
        .Select(g => new { Machine = g.Key, Count = g.Count() })
        .ToList();

    
    var readerDescIssuesOver = entries
        .GroupBy(e => e.ReaderDesc)  
        .Where(g => g.Count() >= SCAN_THRESHOLDForReader)  
        .Select(g => new { ReaderDesc = g.Key, Count = g.Count() })
        .ToList();

        var readerDescIssuesNear = entries
        .GroupBy(e => e.ReaderDesc)  
        .Where(g => g.Count() + nearReader >= SCAN_THRESHOLDForReader && g.Count() < SCAN_THRESHOLDForReader)  
        .Select(g => new { ReaderDesc = g.Key, Count = g.Count() })
        .ToList();

       



    if (machineIssuesOver.Any() && PanelsOver)
    {
        foreach (var issue in machineIssuesOver)
        {
            issues.Add($"Machine {issue.Machine} has {issue.Count} scans. Over threshold of {SCAN_THRESHOLDForPannel}");
        }
    }

     if (readerDescIssuesOver.Any() && ReadersOver)
    {
        foreach (var issue in readerDescIssuesOver)
        {
            issues.Add($"Reader {issue.ReaderDesc} : {issue.Count} scans. Over threshold of {SCAN_THRESHOLDForReader}");
        }
    }

     if (afterHours.Any() && afterHoursBool)
    {
        foreach (var scan in afterHours)
            {
                issues.Add($"{scan.IDHash.Substring(0,10)} scanned at {scan.ReaderDesc} at {scan.Time} — outside regular hours.");
            }
    }

    if (machineIssuesNear.Any() && PanelsNear)
    {
        foreach (var issue in machineIssuesNear)
        {
            issues.Add($"Machine {issue.Machine} : {issue.Count} scans. Near threshold of {SCAN_THRESHOLDForPannel}");
        }
    }

    

    if (readerDescIssuesNear.Any() && ReadersNear)
    {
        foreach (var issue in readerDescIssuesNear)
        {
            issues.Add($"Reader {issue.ReaderDesc} : {issue.Count} scans. Near threshold of {SCAN_THRESHOLDForReader}");
        }
    }

    if (duplicateScans.Any() && dupBool)
    {
        foreach (var dup in duplicateScans)
        {
    issues.Add($"Duplicate scan detected for {dup.IDHash.Substring(0,10)} at {dup.ReaderDesc} at {dup.Time}.");
        }
    }

   
    if (!issues.Any())
    {
        issues.Add("No issues detected with machines or readers.");
    }

    return issues;
}



    public DateTime GetFirstDate()
{
    return Entries
        .Select(e => DateTime.TryParse(e.Time, out var dt) ? dt : (DateTime?)null)
        .Where(dt => dt.HasValue)
        .Select(dt => dt.Value)
        .OrderBy(dt => dt)
        .FirstOrDefault();
}

public DateTime GetLastDate()
{
    
    return Entries
        .Select(e => DateTime.TryParse(e.Time, out var dt) ? dt : (DateTime?)null)
        .Where(dt => dt.HasValue)
        .Select(dt => dt.Value)
        .OrderByDescending(dt => dt)
        .FirstOrDefault();
}








    private List<string> GetTopActivePeopleNames(int topN = 5)
{
    return Entries
        .GroupBy(e => e.IDHash.Substring(0,10))
        .OrderByDescending(g => g.Count())
        .Take(topN)
        .Select(g => g.Key)
        .ToList();
}

private List<double> GetTopActivePeopleCounts(int topN = 5)
{
    return Entries
        .GroupBy(e => e.IDHash)
        .OrderByDescending(g => g.Count())
        .Take(topN)
        .Select(g => (double)g.Count()) // Convert count to double
        .ToList();
}

  private List<string> GetTopActiveReaders(int topN = 5)
{
    return Entries
        .GroupBy(e => e.ReaderDesc.Substring(22))
        .OrderByDescending(g => g.Count())
        .Take(topN)
        .Select(g => g.Key)
        .ToList();
}

private List<double> GetTopActiveReadersCounts(int topN = 5)
{
    return Entries
        .GroupBy(e => e.ReaderDesc)
        .OrderByDescending(g => g.Count())
        .Take(topN)
        .Select(g => (double)g.Count()) // Convert count to double
        .ToList();
}

private List<string> GetTopActivePanels(int topN = 5)
{
    return Entries
        .GroupBy(e => e.Machine.ToString())
        .OrderByDescending(g => g.Count())
        .Take(topN)
        .Select(g => g.Key)
        .ToList();
}

private List<double> GetTopActivePanelCounts(int topN = 5)
{
    return Entries
        .GroupBy(e => e.Machine.ToString())
        .OrderByDescending(g => g.Count())
        .Take(topN)
        .Select(g => (double)g.Count()) // Convert count to double
        .ToList();
}



    private Dictionary<string, List<ReaderEvent>> OrganizeEventsByReader(List<ReaderEvent> events)
    {
        var dictionary = new Dictionary<string, List<ReaderEvent>>();
        foreach (var evt in events)
        {
            string readerId = $"{evt.DevID}-{evt.Machine}";
            if (!dictionary.ContainsKey(readerId))
            {
                dictionary[readerId] = new List<ReaderEvent> { evt };
            }
            else
            {
                dictionary[readerId].Add(evt);
            }
        }
        return dictionary;
    }

    public List<string> GetLocations()
{
    return Entries.Select(e => e.Location).Distinct().ToList();
}
private int GetUniquePeopleCount()
{
    return Entries.Select(e => e.IDHash).Distinct().Count();
}


    private Dictionary<string, List<ReaderEvent>> OrganizeEventsByDayOfWeek(List<ReaderEvent> events)
    {
        var dictionary = new Dictionary<string, List<ReaderEvent>>
        {
            {"Sunday", new List<ReaderEvent>()},
            {"Monday", new List<ReaderEvent>()},
            {"Tuesday", new List<ReaderEvent>()},
            {"Wednesday", new List<ReaderEvent>()},
            {"Thursday", new List<ReaderEvent>()},
            {"Friday", new List<ReaderEvent>()},
            {"Saturday", new List<ReaderEvent>()}
        };

        

        foreach (var evt in events)
        {
            if (DateTime.TryParse(evt.Time, out DateTime eventDate))
            {
                string dayOfWeek = eventDate.ToString("dddd");
                dictionary[dayOfWeek].Add(evt);
                
            }
        }
        Series.Clear();
        Series.Add(new ChartSeries() { Name = "# of Entries", Data = new double[] { dictionary["Sunday"].Count, dictionary["Monday"].Count, dictionary["Tuesday"].Count, dictionary["Wednesday"].Count, dictionary["Thursday"].Count, dictionary["Friday"].Count, dictionary["Saturday"].Count} });
        return dictionary;
    }

    public class ReaderEvent
    {
        public string Time { get; }
        public string Location { get; }
        public string ReaderDesc { get; }
        public string IDHash { get; }
        public int DevID { get; }
        public int Machine { get; }

        public ReaderEvent(string time, string location, string readerDesc, string idHash, int devID, int machine)
        {
            Time = time;
            Location = location;
            ReaderDesc = readerDesc;
            IDHash = idHash;
            DevID = devID;
            Machine = machine;
        }
    }

}







