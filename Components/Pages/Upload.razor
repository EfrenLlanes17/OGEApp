@page "/"

@rendermode InteractiveServer

@using MudBlazor
@using MudBlazor.Services;


@inject NavigationManager Navigation

<PageTitle>Upload</PageTitle>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">

<style>
    body {
        background-color: black;
        color: white;
        font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif
    }

    .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            width: 100%;
            height: 100%;
        }
</style>




<div class="container">
<h1 style="font-weight: bold; font-size: 35px; text-align: center; margin-top: 10%;">Welcome To</h1>

<img src="images/whiteInflowLogo.png" alt="Inflow Logo" width="325" height="75" style="align-content: center; margin-top: 1%;">


@* <MudFileUpload T="IBrowserFile" FilesChanged="FileUploaded">
    <ActivatorContent>
        <MudButton Variant="Variant.Filled"
                   Class="custom-upload-button"
                   Style="background-color: black; color: white; font-weight: bold; font-size: 20px; width: 100%; border-width: 1mm; border-color: white; cursor: pointer; text-align: center; margin-top: 10%;"
                   StartIcon="@Icons.Material.Filled.CloudUpload">
            Upload File
        </MudButton>
    </ActivatorContent>
</MudFileUpload> *@



 <label for="fileUpload" class="btn btn-primary rounded-pill"
       style="background-color: black; color: white; font-weight: bold; font-size: 20px; width: 20%; border-width: 1mm; border-color: white; cursor: pointer; text-align: center; margin-top: 10%">
    Upload File
    <InputFile id="fileUpload" OnChange="FileUploaded" accept=".csv" style="display: none;" />
</label>
</div> 

@* @if(file != null || Series.Count != 0){
<MudSimpleTable Style="overflow-x: auto;">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>File Size(bytes)</th>
                </tr>
            </thead>
    using OGEApp.Components.Layout;
    using OGEApp.Components.Layout;
            <tbody>
            <tr>
                    <td>@file.Name</td>
                    <td>@file.Size</td>
              </tr>  
    </tbody>
    </MudSimpleTable> 



    <MudSimpleTable Style="overflow-x: auto; background-color: rgb(75, 72, 72);">
    <thead>
        <tr>
            <th>Day of the Week</th>
            <th>Event Count</th>
        </tr>
    </thead>
    <tbody>
        @foreach (var entry in eventsByDayOfWeek)
        {
            <tr>
                <td>@entry.Key</td>
                <td>@entry.Value.Count</td>
            </tr>
        }
    </tbody>
</MudSimpleTable>



    <div>
    <MudChart ChartType="ChartType.Line" ChartSeries="@Series" @bind-SelectedIndex="Index" XAxisLabels="@XAxisLabels" Width="100%" Height="350px" ChartOptions="@Options"/>
    <MudGrid>
         <MudItem xs="6">
            <MudText Typo="Typo.body1" Class="py-3">Selected: @(Index < 0 ? "None" : Series[Index].Name)</MudText>
        </MudItem>
        <MudItem xs="6">
            <MudSlider @bind-Value="Options.LineStrokeWidth" Min="1" Max="10" Color="Color.Info">Line Width: @Options.LineStrokeWidth.ToString()</MudSlider>
        </MudItem> 
    </MudGrid>
</div>
} *@




@code {

 public static IBrowserFile file { get; set; }
    public static string FileName { get; set; } = "";
    public long FileSize { get; set; }
    public string FileType { get; set; } = "";
    public string ListSize { get; set; } = "";
    public DateTimeOffset LastModified { get; set; }
    public string ErrorMessage { get; set; } = "";

    const int MAX_FILESIZE = 5000 * 1024; // 5 MB

    private Dictionary<string, List<ReaderEvent>> readerEvents = new();
    public static Dictionary<string, List<ReaderEvent>> eventsByDayOfWeek = new();
    public static List<ReaderEvent> Entries = new();

    public static List<ReaderEvent> EntriesWithDups = new();



private int Index = -1; 
    public ChartOptions Options = new ChartOptions();





    
    public static List<ChartSeries> Series = new List<ChartSeries>()
    {
    };

    public static List<ChartSeries> SeriesPeople = new List<ChartSeries>()
    {
    };

    public static List<ChartSeries> SeriesReaders = new List<ChartSeries>()
    {
    };

    public static List<ChartSeries> SeriesTimes = new List<ChartSeries>()
    {
    };

    public static List<ChartSeries> SeriesPanel = new List<ChartSeries>()
    {
    };
    public string[] XAxisLabels = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };

    public static string[] XAxisLabelsforPeople = {};

    public static string[] XAxisLabelsforReaders = {};

    public static string[] XAxisLabelsforTimes = {};

    public static string[] XAxisLabelsforPanels = {};

    public static DateTime firstDay;
    public static DateTime LastDay;


    public static List<string> listOfErrors = new List<string>();

public static TimeOnly? openTime { get; set; } = new TimeOnly(9, 0);   // 9:00 AM
public static TimeOnly? closeTime { get; set; } = new TimeOnly(17, 0); // 5:00 PM

public static Boolean operating247 { get; set; } = true;


public static int SCAN_THRESHOLDForPannel = 4000;

public static int SCAN_THRESHOLDForReader = 2000;

public static int nearPannel = 100;

public static int nearReader = 100;

public static Boolean PanelsOver= true;

public static Boolean PanelsNear= true;

public static Boolean ReadersOver= true;

public static Boolean ReadersNear= true;

public static Boolean afterHoursBool = true;

public static Boolean dupBool = false;

public static int dupMin = 60;


    public async Task FileUploaded(InputFileChangeEventArgs e)
    {
        
        var browserFile = e.File;
        file = browserFile;

        if (browserFile != null)
        {
            FileSize = browserFile.Size;
            FileType = browserFile.ContentType;
            FileName = browserFile.Name;
            LastModified = browserFile.LastModified;

            try
            {
                using var memoryStream = new MemoryStream();
                await browserFile.OpenReadStream(MAX_FILESIZE).CopyToAsync(memoryStream);

                memoryStream.Position = 0;
                using var reader = new StreamReader(memoryStream);

                string line;
                bool firstLine = true;
                Entries.Clear();
                EntriesWithDups.Clear();

                while ((line = await reader.ReadLineAsync()) != null)
                {
                    if (!firstLine)
                    {
                        var columns = line.Split(',');
                        Entries.Add(new ReaderEvent(columns[0], columns[1], columns[2], columns[3], int.Parse(columns[4]), int.Parse(columns[5])));
                    }
                    else
                    {
                        firstLine = false;
                    }
                }
                
                EntriesWithDups = Entries;

                // Identify duplicate scans
                var duplicateScans = Entries
                    .OrderBy(e => e.IDHash).ThenBy(e => e.Time)
                    .GroupBy(e => e.IDHash)
                    .SelectMany(group =>
                        group.Zip(group.Skip(1), (a, b) => new
                        {
                            Prev = a,
                            Curr = b,
                            PrevTime = DateTime.Parse(a.Time),
                            CurrTime = DateTime.Parse(b.Time)
                        })
                        .Where(pair =>
                            pair.Prev.ReaderDesc == pair.Curr.ReaderDesc &&
                            pair.Prev.IDHash == pair.Curr.IDHash &&
                            pair.Prev.DevID == pair.Curr.DevID &&
                            pair.Prev.Machine == pair.Curr.Machine &&
                            pair.CurrTime == pair.PrevTime
                        )
                        .Select(pair => pair.Curr)
                    )
                    .ToHashSet(); // So we can efficiently remove them

                // Remove duplicates from entries
                Entries = Entries.Where(e => !duplicateScans.Contains(e)).ToList();

                
            
                ListSize = Entries.Count.ToString();
                readerEvents = OrganizeEventsByReader(Entries);
                eventsByDayOfWeek = OrganizeEventsByDayOfWeek(Entries);
            
                SeriesPeople.Clear();
                SeriesPeople.Add(new ChartSeries() { Name = "# of Entries", Data = GetTopActivePeopleCounts().ToArray()});
                XAxisLabelsforPeople = GetTopActivePeopleNames().ToArray();

                SeriesReaders.Clear();
                SeriesReaders.Add(new ChartSeries() { Name = "# of Entries", Data = GetTopActiveReadersCounts().ToArray()});
                XAxisLabelsforReaders= GetTopActiveReaders().ToArray();

                SeriesTimes.Clear();
                SeriesTimes.Add(new ChartSeries() { Name = "# of Entries", Data = GetHourCounts().ToArray()});
                XAxisLabelsforTimes= GetMostActiveHours().ToArray();

                SeriesPanel.Clear();
                SeriesPanel.Add(new ChartSeries() { Name = "# of Entries", Data = GetTopActivePanelCounts().ToArray()});
                XAxisLabelsforPanels= GetTopActivePanels().ToArray();

                @* Console.WriteLine(Entries.Last().Time);
                Console.WriteLine( DateTime.Parse(Entries.Last().Time).ToString());
                Console.WriteLine(GetFirstDate().ToString());
                Console.WriteLine(GetLastDate().ToString()); *@

                @* foreach(string s in CheckForPotentialIssues(Entries).ToArray()){
                   Console.WriteLine(s);
                } *@
                @* Console.WriteLine(CheckForPotentialIssues(Entries).Count); *@

                
                listOfErrors = CheckForPotentialIssues(EntriesWithDups);

                 @* List<string> machineIssues = Entries
                    .GroupBy(e => e.DevID)  
                    .Select(g => g.Key.ToString() + " "+ g.Count().ToString())  
                    .ToList();

               
                
                    Console.WriteLine(machineIssues.Count); *@
                


                
                
                
                firstDay = GetFirstDate();
                LastDay = GetLastDate().AddDays(1);

                Pages.Activity.selectedDateMin = firstDay;
                Pages.Activity.selectedDateMax = LastDay;

                Pages.Activity.entriesAndExit =  Entries.Count;

                Pages.Activity.amountPeople =  GetUniquePeopleCount();

                Components.Pages.Activity.listOflocations.Clear();
                foreach(string s in GetLocations()){
                    Components.Pages.Activity.listOflocations.Add(s);
                }
                Components.Pages.Activity.location = GetLocations().ToArray()[0];



                Navigation.NavigateTo("/Activity");
            }
           catch (Exception exception)
{
    ErrorMessage = exception.Message;
    Console.WriteLine($"Exception: {exception.Message}");
    Console.WriteLine($"Stack Trace: {exception.StackTrace}");
}

        }
    }

    public List<string> CheckForPotentialIssues(List<ReaderEvent> entries)
{
    @* int SCAN_THRESHOLDForPannel = 4000; //4000
    int nearPannel = 100;

    int SCAN_THRESHOLDForReader = 2000; //2000
    int nearReader = 100; *@

    
var openingTime = Upload.openTime ?? new TimeOnly(5, 0);
var closingTime = Upload.closeTime ?? new TimeOnly(17, 0);

// List for issues
List<string> issues = new List<string>();

@if(!Upload.operating247){

var afterHours = entries
    .Where(e =>
    {
        // Parse the time string into a DateTime (assumed to be in UTC)
        if (!DateTime.TryParse(e.Time, out DateTime utcTime))
            return false;

        // Convert to Central Time (handles Daylight Saving automatically)
        TimeZoneInfo cst = TimeZoneInfo.FindSystemTimeZoneById("Central Standard Time");
        DateTime localTime = TimeZoneInfo.ConvertTimeFromUtc(utcTime.ToUniversalTime(), cst);

        // Compare just the time portion
        var timeOnly = TimeOnly.FromDateTime(localTime);
        return timeOnly < openingTime || timeOnly > closingTime;
    })
    .Select(e => new { e.IDHash, e.Time, e.ReaderDesc })
    .ToList();

     if (afterHours.Any() && afterHoursBool)
    {
        foreach (var scan in afterHours)
            {
                DateTime utcTime = DateTime.Parse(scan.Time).ToUniversalTime();
                TimeZoneInfo centralZone = TimeZoneInfo.FindSystemTimeZoneById("Central Standard Time");
                DateTime centralTime = TimeZoneInfo.ConvertTimeFromUtc(utcTime, centralZone);
                issues.Add($"{scan.IDHash.Substring(0,10)} scanned at {scan.ReaderDesc} at {centralTime} â€” outside regular hours.");
            }
    }

}

    var duplicateScans = entries
    .OrderBy(e => e.IDHash).ThenBy(e => e.Time)
    .GroupBy(e => e.IDHash)
    .SelectMany(group =>
        group.Zip(group.Skip(1), (a, b) => new
        {
            Prev = a,
            Curr = b,
            PrevTime = DateTime.Parse(a.Time),
            CurrTime = DateTime.Parse(b.Time)
        })
        .Where(pair =>
            pair.Prev.ReaderDesc == pair.Curr.ReaderDesc &&
            pair.Prev.IDHash == pair.Curr.IDHash &&
            pair.Prev.DevID == pair.Curr.DevID &&
            pair.Prev.Machine == pair.Curr.Machine &&
            pair.CurrTime == pair.PrevTime
        )
        .Select(pair => pair.Curr)
    )
    .GroupBy(d => d.ReaderDesc)
    .Where(g => g.Count() > dupMin)
    .SelectMany(g => g)
    .ToList();



   
    var machineIssuesOver = entries
        .GroupBy(e => e.Machine)  
        .Where(g => g.Count() >= SCAN_THRESHOLDForPannel)
        .Select(g => new { Machine = g.Key, Count = g.Count() })
        .ToList();

         var machineIssuesNear = entries
        .GroupBy(e => e.Machine)  
        .Where(g => g.Count() + nearPannel >= SCAN_THRESHOLDForPannel && g.Count() < SCAN_THRESHOLDForPannel)
        .Select(g => new { Machine = g.Key, Count = g.Count() })
        .ToList();

    
    var readerDescIssuesOver = entries
        .GroupBy(e => e.ReaderDesc)  
        .Where(g => g.Count() >= SCAN_THRESHOLDForReader)  
        .Select(g => new { ReaderDesc = g.Key, Count = g.Count() })
        .ToList();

        var readerDescIssuesNear = entries
        .GroupBy(e => e.ReaderDesc)  
        .Where(g => g.Count() + nearReader >= SCAN_THRESHOLDForReader && g.Count() < SCAN_THRESHOLDForReader)  
        .Select(g => new { ReaderDesc = g.Key, Count = g.Count() })
        .ToList();

       



    if (machineIssuesOver.Any() && PanelsOver)
    {
        foreach (var issue in machineIssuesOver)
        {
            issues.Add($"Panel {issue.Machine} has {issue.Count} scans. Over threshold of {SCAN_THRESHOLDForPannel}");
        }
    }

     if (readerDescIssuesOver.Any() && ReadersOver)
    {
        foreach (var issue in readerDescIssuesOver)
        {
            issues.Add($"Reader {issue.ReaderDesc} : {issue.Count} scans. Over threshold of {SCAN_THRESHOLDForReader}");
        }
    }

    

    if (machineIssuesNear.Any() && PanelsNear)
    {
        foreach (var issue in machineIssuesNear)
        {
            issues.Add($"Panel {issue.Machine} : {issue.Count} scans. Near threshold of {SCAN_THRESHOLDForPannel}");
        }
    }

    

    if (readerDescIssuesNear.Any() && ReadersNear)
    {
        foreach (var issue in readerDescIssuesNear)
        {
            issues.Add($"Reader {issue.ReaderDesc} : {issue.Count} scans. Near threshold of {SCAN_THRESHOLDForReader}");
        }
    }

    if (duplicateScans.Any() && dupBool)
{
    var groupedByReader = duplicateScans
        .GroupBy(d => d.ReaderDesc)
        .Select(g => new { ReaderDesc = g.Key, Count = g.Count() });

    foreach (var group in groupedByReader)
    {
        issues.Add($"{group.ReaderDesc} has {group.Count} duplicate scans.");
    }
}

   
    if (!issues.Any())
    {
        issues.Add("No issues detected with machines or readers.");
    }

    return issues;
}



    public DateTime GetFirstDate()
{
    return Entries
        .Select(e => DateTime.TryParse(e.Time, out var dt) ? dt : (DateTime?)null)
        .Where(dt => dt.HasValue)
        .Select(dt => dt.Value)
        .OrderBy(dt => dt)
        .FirstOrDefault();
}

public DateTime GetLastDate()
{
    
    return Entries
        .Select(e => DateTime.TryParse(e.Time, out var dt) ? dt : (DateTime?)null)
        .Where(dt => dt.HasValue)
        .Select(dt => dt.Value)
        .OrderByDescending(dt => dt)
        .FirstOrDefault();
}


public List<string> GetMostActiveHours()
{
    TimeZoneInfo centralZone = TimeZoneInfo.FindSystemTimeZoneById("Central Standard Time");

    return Entries
        .Select(e =>
        {
            if (DateTime.TryParse(e.Time, out var utcTime))
            {
                utcTime = DateTime.SpecifyKind(utcTime, DateTimeKind.Utc);
                return TimeZoneInfo.ConvertTimeFromUtc(utcTime, centralZone);
            }
            return (DateTime?)null;
        })
        .Where(dt => dt.HasValue)
        .GroupBy(dt => dt.Value.Hour)
        .OrderByDescending(g => g.Count())
        .Take(5)
        .Select(g => $"{g.Key:00}:00")
        .ToList();
}




public List<double> GetHourCounts()
{
    TimeZoneInfo centralZone = TimeZoneInfo.FindSystemTimeZoneById("Central Standard Time");

    return Entries
        .Select(e =>
        {
            if (DateTime.TryParse(e.Time, out var utcTime))
            {
                utcTime = DateTime.SpecifyKind(utcTime, DateTimeKind.Utc);
                return TimeZoneInfo.ConvertTimeFromUtc(utcTime, centralZone);
            }
            return (DateTime?)null;
        })
        .Where(dt => dt.HasValue)
        .GroupBy(dt => dt.Value.Hour)
        .OrderByDescending(g => g.Count())
        .Take(5)
        .Select(g => (double)g.Count())
        .ToList();
}







    private List<string> GetTopActivePeopleNames(int topN = 5)
{
    return Entries
        .GroupBy(e => e.IDHash.Substring(0,10))
        .OrderByDescending(g => g.Count())
        .Take(topN)
        .Select(g => g.Key)
        .ToList();
}

private List<double> GetTopActivePeopleCounts(int topN = 5)
{
    return Entries
        .GroupBy(e => e.IDHash)
        .OrderByDescending(g => g.Count())
        .Take(topN)
        .Select(g => (double)g.Count()) // Convert count to double
        .ToList();
}

  private List<string> GetTopActiveReaders(int topN = 5)
{
    //assums location name is in teh readr desc
    return Entries
        .GroupBy(e => e.ReaderDesc.Substring(e.Location.Length))
        .OrderByDescending(g => g.Count())
        .Take(topN)
        .Select(g => g.Key)
        .ToList();
}

private List<double> GetTopActiveReadersCounts(int topN = 5)
{
    return Entries
        .GroupBy(e => e.ReaderDesc)
        .OrderByDescending(g => g.Count())
        .Take(topN)
        .Select(g => (double)g.Count()) // Convert count to double
        .ToList();
}

private List<string> GetTopActivePanels(int topN = 5)
{
    return Entries
        .GroupBy(e => e.Machine.ToString())
        .OrderByDescending(g => g.Count())
        .Take(topN)
        .Select(g => g.Key)
        .ToList();
}

private List<double> GetTopActivePanelCounts(int topN = 5)
{
    return Entries
        .GroupBy(e => e.Machine.ToString())
        .OrderByDescending(g => g.Count())
        .Take(topN)
        .Select(g => (double)g.Count()) // Convert count to double
        .ToList();
}



    private Dictionary<string, List<ReaderEvent>> OrganizeEventsByReader(List<ReaderEvent> events)
    {
        var dictionary = new Dictionary<string, List<ReaderEvent>>();
        foreach (var evt in events)
        {
            string readerId = $"{evt.DevID}-{evt.Machine}";
            if (!dictionary.ContainsKey(readerId))
            {
                dictionary[readerId] = new List<ReaderEvent> { evt };
            }
            else
            {
                dictionary[readerId].Add(evt);
            }
        }
        return dictionary;
    }

    public List<string> GetLocations()
{
    return Entries.Select(e => e.Location).Distinct().ToList();
}
private int GetUniquePeopleCount()
{
    return Entries.Select(e => e.IDHash).Distinct().Count();
}


    private Dictionary<string, List<ReaderEvent>> OrganizeEventsByDayOfWeek(List<ReaderEvent> events)
    {
        var dictionary = new Dictionary<string, List<ReaderEvent>>
        {
            {"Sunday", new List<ReaderEvent>()},
            {"Monday", new List<ReaderEvent>()},
            {"Tuesday", new List<ReaderEvent>()},
            {"Wednesday", new List<ReaderEvent>()},
            {"Thursday", new List<ReaderEvent>()},
            {"Friday", new List<ReaderEvent>()},
            {"Saturday", new List<ReaderEvent>()}
        };

        

        foreach (var evt in events)
        {
            if (DateTime.TryParse(evt.Time, out DateTime eventDate))
            {
                string dayOfWeek = eventDate.ToString("dddd");
                dictionary[dayOfWeek].Add(evt);
                
            }
        }
        Series.Clear();
        Series.Add(new ChartSeries() { Name = "# of Entries", Data = new double[] { dictionary["Sunday"].Count, dictionary["Monday"].Count, dictionary["Tuesday"].Count, dictionary["Wednesday"].Count, dictionary["Thursday"].Count, dictionary["Friday"].Count, dictionary["Saturday"].Count} });
        return dictionary;
    }

    public class ReaderEvent
    {
        public string Time { get; }
        public string Location { get; }
        public string ReaderDesc { get; }
        public string IDHash { get; }
        public int DevID { get; }
        public int Machine { get; }

        public ReaderEvent(string time, string location, string readerDesc, string idHash, int devID, int machine)
        {
            Time = time;
            Location = location;
            ReaderDesc = readerDesc;
            IDHash = idHash;
            DevID = devID;
            Machine = machine;
        }
    }

}







